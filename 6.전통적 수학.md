# 전통적 수학에서 가능하지만 Agda에서 불가능한 것
## Double Negation Elimination
전통적 논리학에서 명제 P에 대해, ¬¬P이면 P이다. 이를 Double Negation Elimination이라고 이야기한다. 그런데 Agda에서 Double Negation Elimination을 나타내는 함수를 만들고자 하면:
```agda
f : {P : Set} → ¬ (¬ P) → P
f = ?
```
만들 수 없다. 이런 함수를 만들 수 없는 이유는, Agda에서 값을 만들기 위해서는 그 타입의 constructor를 이용해서 값을 만들어내야 하는데, 함수가 입력받은 ¬ (¬ P) 타입의 값은 P 타입의 값을 만들어내는 과정에 대한 정보를 전혀 제공해주지 않기 때문이다. ¬ (¬ P) 타입의 값은 "P 타입의 값이 없다는 것은 거짓이다" 라는 것을 알려줄 뿐이다.

이는 Agda에서는 수학에서의 귀류법을 사용할 수 없음을 의미한다. 귀류법은 P가 거짓임을 가정했을 때 모순이 발생한다는 것을 보임으로서 P가 거짓이 아님을 보이고, Double Negation Elimination으로 P를 얻어내 최종적으로 P를 증명하는 증명 방법이다. 그런데 Agda에서는 Double Negation Elimination이 불가능하기 때문에 귀류법을 사용할 수 없다.

## Law of excluded middle
전통적 논리학에서 모든 명제는 참 또는 거짓이다. 참인지 거짓인지 결정할 수 없을 수는 있지만, 참이거나 거짓이거나 둘 중 하나라는 것은 참이다. 그런데 이걸 Agda에서 만들려고 하면:
```agda
f : (A : Set) → A ⊎ (¬ A)
f = ?
```
불가능하다. 이것도 Double Negation Elimination과 비슷한 이유 때문인데, A 타입의 값과 (¬ A) 타입의 값 중에서 A 타입의 값을 만들어야 하는 경우라면 A 타입의 값을 만들어낼 방법을 알 수 없기 때문이다.

# 가능하게 만들기
그런데 이 둘을 사용할 수 없으면, 기존의 수학 세계에서 이루어진 증명들 중 많은 수의 증명들을 사용할 수 없다. 그리고 이 둘이 없는 경우 증명이 불가능한 명제들도 있다. 그렇기 때문에 만약 Agda에서 전통적 수학을 하고자 하는 경우에는 이 둘을 사용할 수 있도록 수학에서 '증명'에 대응되는 Agda의 대상을 'P 타입의 값'에서, 'P의 Double Negation 타입의 값'으로 넓힐 필요가 있다.
## Double Negation된 타입을 명제로 보기
```agda
(P → ⊥) → ⊥
```
위 타입의 값의 존재는, P 타입의 값이 존재하지 않음이 거짓임을 의미한다. 즉 P 타입의 값이 존재한다는 것, P 의 증명이 존재한다는 것을 의미한다. 그럼 이를 P가 참임을 의미하는 것으로 볼 수 있지 않을까? P에 대한 정확한 증명을 알지는 못하지만, P가 참이라고 말하기에는 충분해보인다.

|Agda|수학|
|---|---|
|타입 P|명제 P|
|P 타입의 값|P의 증명|
|(P → ⊥) → ⊥ 타입의 값|P의 증명|

만약 이를 P가 참임을 의미하는 것으로 받아들이면 위와 같은 대응표가 만들어진다. 그냥 P 타입의 값도 여전히 P의 증명이 될 수 있는 이유는, P 타입의 값으로 (P → ⊥) → ⊥ 타입의 값을 만들 수 있기 때문이다.

```agda
¬¬_ : Set → Set
¬¬ P = (P → ⊥) → ⊥
```

편의를 위해 Double negation된 타입을 만들어주는 함수를 만들 수 있다.

|Agda|수학|
|---|---|
|타입 P|명제 P|
|P 타입의 값|P의 증명|
|¬¬ P 타입의 값|P의 증명|

정의한 기호로 다시 쓰면 이렇다.

## Double Negation Elimination
```agda
double-neg-elim : {P : Set} → ¬ (¬ P) → ¬¬ P
double-neg-elim x = x
```
새로운 표에 따르면, "¬¬P 일때 P이다" 를 의미하는 함수를 만들 수 있다. Double Negation Elimination이다.

## Law of excluded middle
```agda
law-of-excluded-middle : (P : Set) → ¬¬ (P ⊎ (¬ P))
law-of-excluded-middle P a = a (inj₂ (λ x → a (inj₁ x)))
```
"P 또는 ¬P이다"를 의미하는 함수도 만들 수 있다. Law of excluded middle이다.

# Double negation을 편하게 쓸 수 있게 하기
새로운 '증명'의 정의를 사용하면 고전적 대상들을 증명할 수 있긴 하다. 그런데, 증명하는 과정은 끔찍하다.

예를 들어서 Double negation 꼴인 다른 함수 f : P → ¬¬Q, g : Q → ¬¬R을 활용해서 새로운 타입 ¬¬S를 증명하고 싶다고 해 보자. 그리고 S의 증명에는 ¬¬R이 핵심적인 역할을 한다고 가정하자. 어찌저찌 P를 얻어서, f에 입력하면 (Q → ⊥) → ⊥를 얻는다. 이제 g에 Q를 넣어야 하는데, (Q → ⊥) → ⊥에서 Q를 만들 수가 없기 때문에, 빙빙 돌아 ¬¬R를 얻어내야 한다.

이런 귀찮음을 해결하기 위해서는 다음과 같은 함수가 필요하다.
```agda
¬¬ P → P
```
그런데 앞서 봤듯, 이 함수는 있을 수가 없다!

하지만 이것과 비슷한 효과를 주는 함수를 만들 수는 있다.

## Double negation monad (bind function)
```agda
_>>=_ : {A B : Set} → ¬¬ A → (A → ¬¬ B) → ¬¬ B
a >>= f = λ z₁ → a (λ z₂ → f z₂ z₁)
```

이 함수를 이용하면 A를 입력받아 ¬¬ B를 만드는 함수(A → ¬¬ B)를 작성하고, ¬¬ A를 넣으면 ¬¬ B를 얻을 수 있다.

### 예시: (A면 B, B면 C)라면 (A면 C)이다.
```agda
f : {A B C : Set} → (A → ¬¬ B) → (B → ¬¬ C) → (A → ¬¬ C)
f a-to-b b-to-c a = 
  a-to-b a >>= λ b →
  b-to-c b
```
`a-to-b a`로 `¬¬ B`를 만들고, 뒤에 `B → ¬¬ C`함수를 넣어서 `¬¬ C`를 얻는다.

### 예시: (A면 B, B면 C, C면 D, D면 E)라면 (A면 E)이다.
```agda
f : {A B C D E : Set} → (A → ¬¬ B) → (B → ¬¬ C) → (C → ¬¬ D) → (D → ¬¬ E) → (A → ¬¬ E)
f a-to-b b-to-c c-to-d d-to-e a = 
  a-to-b a >>= λ b →
  b-to-c b >>= λ c →
  c-to-d c >>= λ d →
  d-to-e d
```
연속해서 사용하면 위와 같이 사용할 수 있다.

## Do notation
Agda는 [Do-notation](https://agda.readthedocs.io/en/v2.6.3/language/syntactic-sugar.html#do-notation)이라는 편의기능을 제공해 >>=를 활용한 표현을 간결하게 쓸 수 있도록 해 준다.

```agda
do x ← m
   m'
```
위와 같은 구문을 작성하면
```
m >>= λ x →
m'
```
이런 구문으로 자동으로 Agda가 해석한다.

### 예시: (A면 B, B면 C)라면 (A면 C)이다.
```agda
f : {A B C : Set} → (A → ¬¬ B) → (B → ¬¬ C) → (A → ¬¬ C)
f a-to-b b-to-c a = do 
  b ← a-to-b a
  b-to-c b
```

### 예시: (A면 B, B면 C, C면 D, D면 E)라면 (A면 E)이다.
```agda
f : {A B C D E : Set} → (A → ¬¬ B) → (B → ¬¬ C) → (C → ¬¬ D) → (D → ¬¬ E) → (A → ¬¬ E)
f a-to-b b-to-c c-to-d d-to-e a = do
  b ← a-to-b a
  c ← b-to-c b
  d ← c-to-d c
  d-to-e d
```
`←` 표시가 ¬¬을 제거하는 역할을 하는 것 처럼 보인다.

# 준비 완료!
이제 Agda로 수학을 하기 위한 도구들이 모두 갖춰졌다. 이제 Agda를 활용해서 수학기초론부터 사칙연산, 미적분, 위상수학 등 모든 수학을 형식화할 수 있다. 원한다면 물리학, 컴퓨터 과학 등 다른 학문의 연역적인 부분들을 형식화할 수도 있다.

이제 준비가 완료됐으니 이 가이드의 다음 챕터부터는 사칙연산, 초등학교/중학교/고등학교 수학 내용을 다룰 것이다.

# 참고
- [Classical Mathematics for a Constructive World](https://arxiv.org/ftp/arxiv/papers/1008/1008.1213.pdf)